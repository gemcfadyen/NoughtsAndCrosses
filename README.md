NoughtsAndCrosses
=================

This project is running on the continuous build server drone.io.
The current [![Build Status](https://drone.io/github.com/gemcfadyen/NoughtsAndCrosses/status.png)](https://drone.io/github.com/gemcfadyen/NoughtsAndCrosses/latest)

Initial Idea
============

Kata to simulate a game of noughts and crosses

Following on from a LSCC (London Software Craftsmanship Community) hands on session where we had to implement solutions to the tic-tac-toe game, upload them to a server and play against each other, I decided to implement a game of noughts and crosses such that one player is you, the human, whilst the other is your program.

My end goal/idea is that as a starting point the player to go first is randomly generated by the game.  A random seed is used for this so that in testing, I can determine who the first player will be.

Approach
========
As the next step I got the computer taking the first go and writing the output to the console.

This then allowed the human user to type in their next move.

This was just a little proof of concept to ensure that the idea would work. It seem's to...

Testing the simulation of a human entering their input is something I need to think about therefore, knowing that the concept wil work from the POC, I decided to start simple and get the alorithm of the game in place initially. Once that is complete I can simply replace one player with that of a 'human player' and introduce the console reading/writing.

As this is very much work in progress, the code will go through various states. I've made a list of a few reminders below, and in the code via comments, which will dissappear as the functionality is put in place.

Hopefully by the end a game of noughts and crosses will be in place!


1. The Game algorithm was put in place. TDD was used to allow the dependant objects to be formed, and Mockito was used to mock out all the dependency interactions.
2. I started fleshing out the Player - deciding to turn the Player into an interface so that two types of player could exist - the AutomatedPlayer (who is using an algorithm to decide the next move) and ultimatly a HumanPlayer who will type in their input from the command line.
3. I debated as to whether the algorithm for the AutomatedPlayer should live in the Grid class or the AutomatedPlayer. In the end I decided it should live in the AutomatedPlayer, afterall each player should devise their own strategy. I was keen however on keeping the Grid akin to a First class collection, therefore I envisage lots of methods being added to the Grid to allow the different players to query its state.

ToDo:

* Validation of the input 
	** Should the user just provide an index which is then set by the computer (Will stop a human user putting their 	input in an already occupied space)
	** Each time a move is made, the result needs to be checked to see if there is a win. If so the game ends.
	** Each time the computer makes a move it needs to check f the there is a blocking move to be made (eg xx-----o- 	would need blocking otherwise the x will win.
* Functionality moved into the Player classes rather than all just happening in one block.


Questions:
* When prompting the user for input -- how can this be unit tested? ie to emulate a user inputting their go.
